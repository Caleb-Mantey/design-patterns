# Structural Patterns

Structural patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient. This pattern focuses on the structure of classes and objects in an application

## Types of Structural Patterns

### [Adapter Pattern](Adapter%20Pattern/)

The adapter pattern is used to convert the interface of a class into another type. It allows object with incompatible interfaces to collaborate

[View Example](Adapter%20Pattern/)

### [Composite Pattern](Composite%20Pattern/)

The composite is a design pattern that lets you compose objects into tree structures and then work with these structures as if they were individual objects. It represents object hierarchies where individual objects and compositions of objects are treated the same way.

[View Example](Composite%20Pattern/)

### [Decorator Pattern](Decorator%20Pattern/)

This Decorator pattern lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors. It allows dynamically adding of new behaviours to an object.

[View Example](Decorator%20Pattern/)

### [Facade Pattern](Facade%20Pattern/)

Facade is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of classes. Clients can talk to the facade rather than individual classes in the subsystem (library or framework).

[View Example](Facade%20Pattern/)

### [Flyweight Pattern](Flyweight%20Pattern/)

Flyweight is a structural design pattern that lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object. This pattern is useful for memory management in applications (Example: Loading images or static assets that are used in multiple places in your applications).

[View Example](Flyweight%20Pattern/)
